// Custom DNS Server with Pass-through support for domains

var dgram = require("dgram")

var dnsIP = undefined
var domainConfig = {}

var logRequest
var logHit
var logGeneric

module.exports = {
	start: startDnsServer,

  log: function(fnPtr) { logGeneric = fnPtr },
  logRequest: function(fnPtr) { logRequest = fnPtr },
  logHit: function(fnPtr) { logHit = fnPtr }
}

function startDnsServer(config) {
  if (typeof config === "object")  domainConfig = config

  dnsIP = domainConfig.DNS // Default DNS server for passthrough
  if (!dnsIP)  throw("No default passthrough DNS server provided.")

	var dgram = require("dgram")
  dgram.createSocket("udp4", dnsRequest).bind(53)

  if (typeof logHit === 'function')  logGeneric("DNS Server started")
}


function getDomainIP(requestDomain) {
  if (!typeof domainConfig === "object")  return undefined
  var domains = domainConfig.domains

  for (domain of domains) {
    if (domain.name == requestDomain)
      return domain.ip
  }

  return undefined
}

function dnsRequest(msg, rinfo) {

  var domain = resolveDNSDomain(msg)
  var server = this
  var address = rinfo.address
  var port = rinfo.port

  if (typeof logRequest === 'function')  logRequest("DNS: " + domain)

  var domainIP = getDomainIP(domain)
  if (domainIP) {

    var tag = msg.readUInt16BE(0)
    var ip = dot2num(domainIP)
    var newMsg = getMsg(tag, domain, ip)

    if (typeof logHit === 'function')  logHit("DNS: " + domain + " changed to " + domainIP)

    server.send(newMsg.msg, 0, newMsg.size, port, address)
    return

  }

  // Proxy DNS request with real DNS server
  dgram.createSocket("udp4", function(msg, rinfo) {
    server.send(msg, 0, rinfo.size, port, address)
    this.close()
  }).send(msg, 0, rinfo.size, 53, dnsIP)
}


function resolveDNSDomain(msg) {
    var domain = []
    var index = 12
    var offset

    while (offset = msg.readUInt8(index++)) {
        var sub = ""
        for (var i = 0; i < offset; i++) {
            sub += String.fromCharCode(msg.readUInt8(index++))
        }
        sub && domain.push(sub)
    }
    return domain.join(".")
}

function dot2num(dot) {
  var d = dot.split('.')
  return ((((((+d[0]) * 256) + (+d[1])) * 256) + (+d[2])) * 256) + (+d[3])
}

function getMsg(tag, domain, ip) {
  var msg = {
    size: 0,
    msg: ""
  }

  var offset = 0

  msg.size = 128
  msg.msg = new Buffer(msg.size)
  msg.msg.writeUInt16BE(tag, offset)
  offset += 2
  msg.msg.writeUInt16BE(0x8180, offset)
  offset += 2
  msg.msg.writeUInt32BE(0x00010001, offset)
  offset += 4
  msg.msg.writeUInt32BE(0x00000000, offset)
  offset += 4

  //write domain
  var d = domain.split('.')
  for (var i = 0; i < d.length; i++) {
      var length = d[i].length
      msg.msg.writeUInt8(length, offset++)
      msg.msg.write(d[i], offset, length)
      offset += length
  }
  msg.msg.writeUInt8(0, offset++)

  msg.msg.writeUInt32BE(0x00010001, offset)
  offset += 4
  msg.msg.writeUInt16BE(0xC00C, offset)
  offset += 2
  msg.msg.writeUInt32BE(0x00010001, offset)
  offset += 4
  msg.msg.writeUInt32BE(0x00000C82, offset)
  offset += 4
  msg.msg.writeUInt16BE(0x0004, offset)
  offset += 2
  msg.msg.writeUInt32BE(ip, offset)
  offset += 4

  msg.size = offset
  return msg
}